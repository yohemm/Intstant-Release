# THIS FILE NEED TO BE FULLY IN ENGLISH
name: Semantic Versioning & Changelog
author: Yohem VAXELAIRE
description: Auto-versioning avec semantic commit, gÃ©nÃ©ration changelog et tags Git

branding:
  icon: tag
  color: blue


inputs:
  # Branches to trigger versioning
  trigger-branches:
    description: 'Branches on which to trigger versioning (comma-separated)'
    required: false
    default: main
  
  # Breaking changes indicators
  breaking-change-indicators:
    description: Commit types indicating breaking changes (comma-separated)
    required: false
    default: 'BREAKING CHANGE,!:,\!:'

  # Features commit types
  feature-types:
    description: Commit types considered as features (comma-separated)
    required: false
    default: feat,âœ¨,ğŸš€
  
  # Fixes commit types
  fix-types:
    description: Commit types considered as fixes (comma-separated)
    required: false
    default: fix,ğŸ›
  
  # Refactors commit types
  refactor-types:
    description: Commit types considered as refactors/performance (comma-separated)
    required: false
    default: refactor,â™»ï¸,perf,âš¡,ğŸ¨

  # Configuration Git
  git-user-name:
    description: Git username for commits
    required: false
    default: github-actions[bot]
  
  git-user-email:
    description: Git email for commits
    required: false
    default: github-actions[bot]@users.noreply.github.com
  
  # Configuration versioning
  initial-version:
    description: Initial version if no tags exist
    required: false
    default: v0.0.1
  
  # Configuration changelog
  generate-changelog:
    description: Generate or update CHANGELOG.md
    required: false
    default: true
  
  # Path to changelog file (with name)
  changelog-file:
    description: Path(with name) to the changelog file
    required: false
    default: CHANGELOG.md
  
  # Auto commit changelog
  auto-commit:
    description: Auto-commit changelog updates
    required: false
    default: true
  
  # Create and push Git tags
  create-tags:
    description: Create and push Git tags
    required: false
    default: true
  
  # Create GitHub Release
  create-release:
    description: Create a GitHub Release for the new version
    required: false
    default: false
  
  # Debug mode
  debug:
    description: Debug mode for detailed logs
    required: false
    default: false


outputs:
  current-version:
    description: New version created
    value: ${{ steps.bump.outputs.current_version }}
  
  version-bump:
    description: Bump type (major, minor, patch, none)
    value: ${{ steps.bump.outputs.bump_type }}
  
  changelog-generated:
    description: Inicates if changelog was generated/updated
    value: ${{ steps.changelog.outputs.has_changes }}
  
  tag-created:
    description: Indiques if a new tag was created
    value: ${{ steps.tag.outputs.tag_created }}
    
runs:
  using: 'composite'
  steps:
    - name: 'Setup Git & Checkout'
      shell: bash
      run: |
        git config --global user.name "${{ inputs.git-user-name }}"
        git config --global user.email "${{ inputs.git-user-email }}"
        git fetch --tags --all
        echo "âœ… Git configured and ready"
    
    - name: 'Initialize Variables'
      id: init
      shell: bash
      run: |
        TRIGGER_BRANCHES="${{ inputs['trigger-branches'] }}"
        BRANCH_PATTERN=$(echo "$TRIGGER_BRANCHES" | sed 's/,/|/g')
        BREAKING_INDICATORS="${{ inputs.breaking-change-indicators }}"
        BREAKING_PATTERN=$(echo "$BREAKING_INDICATORS" | sed 's/,/|/g')
        FEATURE_TYPES="${{ inputs.feature-types }}"
        FEATURE_PATTERN=$(echo "$FEATURE_TYPES" | sed 's/,/|/g')
        FIX_TYPES="${{ inputs.fix-types }}"
        FIX_PATTERN=$(echo "$FIX_TYPES" | sed 's/,/|/g')
        REFACTOR_TYPES="${{ inputs.refactor-types }}"
        REFACTOR_PATTERN=$(echo "$REFACTOR_TYPES" | sed 's/,/|/g')
        
        echo "branch_pattern=$BRANCH_PATTERN" >> $GITHUB_ENV
        echo "breaking_pattern=$BREAKING_PATTERN" >> $GITHUB_ENV
        echo "feature_pattern=$FEATURE_PATTERN" >> $GITHUB_ENV
        echo "fix_pattern=$FIX_PATTERN" >> $GITHUB_ENV
        echo "refactor_pattern=$REFACTOR_PATTERN" >> $GITHUB_ENV

        if [ "${{ inputs.debug }}" = "true" ]; then
          echo "ğŸ” [DEBUG] Trigger branches pattern: $BRANCH_PATTERN"
          echo "ğŸ” [DEBUG] Breaking changes pattern: $BREAKING_PATTERN"
          echo "ğŸ” [DEBUG] Feature types pattern: $FEATURE_PATTERN"
          echo "ğŸ” [DEBUG] Fix types pattern: $FIX_PATTERN"
          echo "ğŸ” [DEBUG] Refactor types pattern: $REFACTOR_PATTERN"
        fi


    - name: 'Get Latest Tag'
      id: get_tag
      shell: bash
      run: |
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        
        if [ -z "$LAST_TAG" ]; then
          LAST_TAG="${{ inputs.initial-version }}"
          IS_INITIAL="true"
        else
          IS_INITIAL="false"
        fi
        
        echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
        echo "is_initial=$IS_INITIAL" >> $GITHUB_OUTPUT
        
        if [ "${{ inputs.debug }}" = "true" ]; then
          echo "ğŸ” [DEBUG] Last tag: $LAST_TAG (initial: $IS_INITIAL)"
        fi

    - name: 'Extract Commits'
      id: commits
      shell: bash
      run: |
        LAST_TAG="${{ steps.get_tag.outputs.last_tag }}"
        IS_INITIAL="${{ steps.get_tag.outputs.is_initial }}"
        
        if [ "$IS_INITIAL" = "false" ]; then
          COMMITS=$(git log "${LAST_TAG}..HEAD" --pretty=format:"%s%n%b")
        else
          COMMITS=$(git log HEAD --pretty=format:"%s%n%b")
        fi
        
        echo "commits<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMITS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        if [ "${{ inputs.debug }}" = "true" ]; then
          echo "ğŸ” [DEBUG] Commits found:"
          echo "$COMMITS" | head -10
        fi

    - name: 'Determine Version'
      id: bump
      shell: bash
      run: |
        LAST_TAG="${{ steps.get_tag.outputs.last_tag }}"
        IS_INITIAL="${{ steps.get_tag.outputs.is_initial }}"
        COMMITS="${{ steps.commits.outputs.commits }}"
        
        BUMP_TYPE="none"
        NEW_VERSION="$LAST_TAG"
        
        # Si version initiale, skip le versioning
        if [ "$IS_INITIAL" = "true" ]; then
          NEW_VERSION="${{ inputs.initial-version }}"
          echo "bump_type=initial" >> $GITHUB_OUTPUT
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "ğŸ§© [DEBUG] Initial version, no bump needed"
          fi
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ†• Initial version: $NEW_VERSION"
          exit 0
        fi
        
        # Parser la version
        MAJOR=$(echo "$LAST_TAG" | sed 's/[^0-9.]*//g' | cut -d. -f1)
        MINOR=$(echo "$LAST_TAG" | sed 's/[^0-9.]*//g' | cut -d. -f2)
        PATCH=$(echo "$LAST_TAG" | sed 's/[^0-9.]*//g' | cut -d. -f3)
        
        # DÃ©tecter le type de bump
        if echo "$COMMITS" | grep -E -q "(${{ env.breaking_pattern }})"; then
          BUMP_TYPE="major"
          MAJOR=$((MAJOR + 1))
          MINOR=0
          PATCH=0
        elif echo "$COMMITS" | grep -E -q "^(${{ env.feature_pattern }})"; then
          BUMP_TYPE="minor"
          MINOR=$((MINOR + 1))
          PATCH=0
        elif echo "$COMMITS" | grep -E -q "^((${{ env.fix_pattern }})|(${{ env.refactor_pattern }}))"; then
          BUMP_TYPE="patch"
          PATCH=$((PATCH + 1))
        fi
        
        NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
        
        echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
        if [ "${{ inputs.debug }}" = "true" ]; then
          echo "ğŸ§© [DEBUG] Version bump type: $BUMP_TYPE"
        fi
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        
        if [ "$BUMP_TYPE" != "none" ]; then
          echo "ğŸ“ˆ Version bump: $BUMP_TYPE â†’ $NEW_VERSION"
        else
          echo "â­ï¸ No version bump needed"
        fi
        
        if [ "$BUMP_TYPE" = "none" ]; then
          NEW_VERSION="$LAST_TAG"
        fi

        echo "current_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        if [ "${{ inputs.debug }}" = "true" ]; then
          echo "ğŸ§© [DEBUG] Final new version: $NEW_VERSION"
        fi

    - name: 'Generate Changelog'
      id: changelog
      if: ${{ inputs.generate-changelog == 'true' }}
      shell: bash
      run: |
        LAST_TAG="${{ steps.get_tag.outputs.last_tag }}"
        IS_INITIAL="${{ steps.get_tag.outputs.is_initial }}"
        NEW_VERSION="${{ steps.bump.outputs.new_version }}"
        CHANGELOG_FILE="${{ inputs.changelog-file }}"
        REPO_URL="https://github.com/${{ github.repository }}"
        FEATURE_PATTERN="${{ env.feature_pattern }}"
        FIX_PATTERN="${{ env.fix_pattern }}"
        REFACTOR_PATTERN="${{ env.refactor_pattern }}"
        BREAKING_PATTERN="${{ env.breaking_pattern }}"
        
        TMP_FILE="${CHANGELOG_FILE}.tmp"
        VERSION_TITLE="## $NEW_VERSION"

        FEATURE_COUNT=0
        FIX_COUNT=0
        REFACTOR_COUNT=0
        MISC_COUNT=0

        extract_commits() {
          local pattern="$1"
          echo "$ALL_COMMITS_FORMATTED" | grep -E "^- ${pattern}" | while read -r line; do
            # Si le commit commence par le pattern (type connu)
            if [[ "$line" =~ ^-[[:space:]]$pattern(\(|\\|\!|:) ]]; then
              # echo "New line matched pattern '$pattern': $line" >&2
              echo "$line" | sed -E 's#(\\!:|!:)#:#g; s#^- (feat|fix|refactor|perf)(\(([^)]+)\)):#- \3:#; s#^- :#- #g'
            else
              # echo "Line not matching pattern '$pattern': $line" >&2
              echo "$line"
            fi
          done
        }

        extract_misc_commits() {
          # Tout ce qui n'est pas feat, fix, refactor, perf, BREAKING CHANGE
          echo "$ALL_COMMITS_FORMATTED" \
            | grep -Ev "^- ((feat|fix|refactor|perf)(\(|:)|((${FEATURE_PATTERN})|(${FIX_PATTERN})|(${REFACTOR_PATTERN})))|(${BREAKING_PATTERN})|Merge" | sed -E "s|//||g; s|\\?!:|:|g" || true
        }
        extract_merge_commits() {
          # Tout ce qui n'est pas feat, fix, refactor, perf, BREAKING CHANGE
          echo "$ALL_COMMITS_FORMATTED" \
            | grep "Merge" || true
        }
        
        # En-tÃªte du changelog
        echo "$VERSION_TITLE - $(date +'%Y-%m-%d')" > "$TMP_FILE"
        echo "" >> "$TMP_FILE"
        
        HAS_CHANGES="false"
        
        if [ "$IS_INITIAL" = "false" ]; then
          ALL_COMMITS_FORMATTED="$(git log "${LAST_TAG}..HEAD" --pretty=format:"- %s ([commit %h](${REPO_URL}/commit/%H)) by %an" || true)"
          
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "ğŸ” [DEBUG] All formatted commits:"
            echo "$ALL_COMMITS_FORMATTED" | head -20
          fi

          # Breaking Changes
          BREAKING=$(echo "$ALL_COMMITS_FORMATTED" | grep -E "(${{ env.breaking_pattern }})" | sed -E "s|//||g; s|\\?!:|:|g" || true)
          if [ -n "$BREAKING" ]; then
            echo "### âš ï¸ Breaking Changes" >> "$TMP_FILE"
            echo "${BREAKING//!:/:}" >> "$TMP_FILE"
            echo "" >> "$TMP_FILE"
            HAS_CHANGES="true"
            if [ "${{ inputs.debug }}" = "true" ]; then
              echo "ğŸ” [DEBUG] Breaking changes found in commits:"
              echo "$BREAKING"
            fi
          fi

          
          # Features
          FEATURES=$(extract_commits "(${{ env.feature_pattern }})") || true
          if [ -n "$FEATURES" ]; then
            echo "### ğŸš€ Features" >> "$TMP_FILE"
            echo "$FEATURES" >> "$TMP_FILE"
            echo "" >> "$TMP_FILE"
            FEATURE_COUNT=$(echo "$FEATURES" | wc -l)
            echo "feature_count=$FEATURE_COUNT" >> $GITHUB_ENV
            HAS_CHANGES="true"
            if [ "${{ inputs.debug }}" = "true" ]; then
              echo ""
              echo "ğŸ” [DEBUG] Features found in commits:"
              echo "$FEATURES"
              echo "ğŸ” [DEBUG] Feature count: $FEATURE_COUNT"
            fi
          fi
          # Fixes          
          FIXES=$(extract_commits "(${{ env.fix_pattern }})") || true
          if [ -n "$FIXES" ]; then
            echo "### ğŸ› Fixes" >> "$TMP_FILE"
            echo "$FIXES" >> "$TMP_FILE"
            echo "" >> "$TMP_FILE"
            FIX_COUNT=$(echo "$FIXES" | wc -l)
            echo "fix_count=$FIX_COUNT" >> $GITHUB_ENV
            HAS_CHANGES="true"
            if [ "${{ inputs.debug }}" = "true" ]; then
              echo ""
              echo "ğŸ” [DEBUG] Fixes found in commits:"
              echo "$FIXES"
              echo "ğŸ” [DEBUG] Fix count: $FIX_COUNT"
            fi
          fi
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "Before Refactors check, HAS_CHANGES=$HAS_CHANGES"
          fi
          # Refactors & Performance
          REFACTORS=$(extract_commits "(${{ env.refactor_pattern }})") || true
          if [ -n "$REFACTORS" ]; then
            echo "### â™»ï¸ Refactors / Performance" >> "$TMP_FILE"
            echo "$REFACTORS" >> "$TMP_FILE"
            echo "" >> "$TMP_FILE"
            REFACTOR_COUNT=$(echo "$REFACTORS" | wc -l)
            echo "refactor_count=$REFACTOR_COUNT" >> $GITHUB_ENV
            HAS_CHANGES="true"
            if [ "${{ inputs.debug }}" = "true" ]; then
              echo ""
              echo "ğŸ” [DEBUG] Refactors found in commits:"
              echo "$REFACTORS"
              echo "ğŸ” [DEBUG] Refactor count: $REFACTOR_COUNT"
            fi
          fi

          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "Before Misc check, HAS_CHANGES=$HAS_CHANGES"
          fi
          
          # Others / Misc
          MISC=$(extract_misc_commits) || true
          if [ -n "$MISC" ]; then
            echo "### ğŸ“ Autres changements" >> "$TMP_FILE"
            echo "$MISC" >> "$TMP_FILE"
            echo "" >> "$TMP_FILE"
            MISC_COUNT=$(echo "$MISC" | wc -l)
            echo "misc_count=$MISC_COUNT" >> $GITHUB_ENV
            HAS_CHANGES="true"
            if [ "${{ inputs.debug }}" = "true" ]; then
              echo ""
              echo "ğŸ” [DEBUG] Misc changes found in commits:"
              echo "$MISC"
              echo "ğŸ” [DEBUG] Misc count: $MISC_COUNT"
            fi
          fi

          # --- ğŸ”€ Merges & Pull Requests ---
          MERGE=$(extract_merge_commits) || true
          if [ -n "$MERGE" ]; then
            echo "### ğŸ”€ Merges" >> "$TMP_FILE"
            echo "$MERGE" >> "$TMP_FILE"
            echo "" >> "$TMP_FILE"
            MERGE_COUNT=$(echo "$MERGE" | wc -l)
            echo "merge_count=$MERGE_COUNT" >> $GITHUB_ENV
            HAS_CHANGES="true"
            if [ "${{ inputs.debug }}" = "true" ]; then
              echo ""
              echo "ğŸ” [DEBUG] Merge commits found:"
              echo "$MERGE"
              echo "ğŸ” [DEBUG] Merge count: $MERGE_COUNT"
            fi
          fi
        fi
        
        if [ "$HAS_CHANGES" = "true" ]; then
        
          CONTRIBUTORS=$(git log "${LAST_TAG}..HEAD" --pretty=format:"%an" | sort -u | wc -l)
          FILES_CHANGED=$(git log "${LAST_TAG}..HEAD" --name-only --pretty=format: | sort -u | wc -l)
          START_DATE=$(git log "${LAST_TAG}" -1 --format=%cs)
          END_DATE=$(date +'%Y-%m-%d')
          IMPACT_SCORE=$(( FEATURE_COUNT*3 + FIX_COUNT*2 + REFACTOR_COUNT + MISC_COUNT/2 ))
          echo "period=${START_DATE} â†’ ${END_DATE}" >> $GITHUB_ENV
          echo "contributors=$CONTRIBUTORS" >> $GITHUB_ENV
          echo "files_changed=$FILES_CHANGED" >> $GITHUB_ENV
          echo "impact_score=$IMPACT_SCORE" >> $GITHUB_ENV

          echo "### ğŸ“Š Release Stats" >> "$TMP_FILE"
          echo "- Commits: ${{ env.commit_count }}" >> "$TMP_FILE"
          echo "- Contributors: $CONTRIBUTORS" >> "$TMP_FILE"
          echo "- Files changed: $FILES_CHANGED" >> "$TMP_FILE"
          echo "- Period: $START_DATE â†’ $END_DATE" >> "$TMP_FILE"
          echo "- Impact score: $IMPACT_SCORE ğŸš€" >> "$TMP_FILE"
          echo "" >> "$TMP_FILE"
          
          CONTRIBUTORS_LIST=$(git log "${LAST_TAG}..HEAD" --pretty=format:"%an" | sort -u)
          if [ -n "$CONTRIBUTORS_LIST" ]; then
            echo "### ğŸ¤ Contributors" >> "$TMP_FILE"
            echo "$CONTRIBUTORS_LIST" | sed 's/^/- /' >> "$TMP_FILE"
          fi

          echo "" >> "$TMP_FILE"
          if [ "${LAST_TAG}" != "${NEW_VERSION}" ]; then
            echo "Compare changes: [${LAST_TAG}...${NEW_VERSION}](${REPO_URL}/compare/${LAST_TAG}...${NEW_VERSION})" >> $TMP_FILE
          else
            echo "---" >> "$TMP_FILE"
          fi
          echo "" >> "$TMP_FILE"

          echo "ğŸ“ Changelog updated at $CHANGELOG_FILE"
        else
          echo "â„¹ï¸ No changelog changes to add"
        fi
        
        # Fusionner avec l'ancien changelog
        if [ -f "$CHANGELOG_FILE" ] && [ "$HAS_CHANGES" = "true" ]; then
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "ğŸ” [DEBUG] Merging with existing changelog"
          fi
          
          if [ -f "$CHANGELOG_FILE" ] && grep -q "^$VERSION_TITLE" "$CHANGELOG_FILE"; then
            awk -v ver="$VERSION_TITLE" '
              BEGIN {found=0}
              {
                if ($0 ~ ver && found==0) {found=1; next}
                print
              }' "$CHANGELOG_FILE" > CHANGELOG_OLD.tmp
            cat "$TMP_FILE" CHANGELOG_OLD.tmp > "$CHANGELOG_FILE"
            rm -f "CHANGELOG_OLD.tmp"
          else
            cat "$TMP_FILE" "$CHANGELOG_FILE" > CHANGELOG_NEW.tmp
            mv "CHANGELOG_NEW.tmp" "$CHANGELOG_FILE"
          fi
          rm -f "$TMP_FILE"
        # File not exit and not initial version
        elif [ ! -f "$CHANGELOG_FILE" ] && [ "$IS_INITIAL" = "false" ]; then
          mv "$TMP_FILE" "$CHANGELOG_FILE"
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "ğŸ” [DEBUG] Created new changelog file"
          fi
        else
          rm -f "$TMP_FILE"
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "ğŸ” [DEBUG] No changelog file created or updated"
          fi
        fi

        echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
        
        if [ "${{ inputs.debug }}" = "true" ]; then
          echo "ğŸ§© [DEBUG] has_changes i set to $HAS_CHANGES"
          echo "ğŸ” [DEBUG] Changelog generated: $HAS_CHANGES"
        fi

    - name: 'Commit Changes'
      id: commit
      if: ${{ inputs.auto-commit == 'true' }}
      shell: bash
      run: |
        CHANGELOG_FILE="${{ inputs.changelog-file }}"
        NEW_VERSION="${{ steps.bump.outputs.new_version }}"
        
        if [ -f "$CHANGELOG_FILE" ]; then
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "ğŸ” [DEBUG] Preparing to commit changelog changes"
          fi

          git add "$CHANGELOG_FILE"
          
          if ! git diff --cached --quiet; then
            git commit -m "docs(changelog): update for $NEW_VERSION"
            git push origin HEAD
            echo "âœ… Changelog committed and pushed"
          else
            echo "â„¹ï¸ No changelog changes to commit"
          fi
        fi

    - name: 'Create Tag'
      id: tag
      if: ${{ inputs.create-tags == 'true' }}
      shell: bash
      run: |
        NEW_VERSION="${{ steps.bump.outputs.new_version }}"
        BUMP_TYPE="${{ steps.bump.outputs.bump_type }}"
        # TAG_COMMIT=$(git rev-list -n 1 "$NEW_VERSION" 2>/dev/null || echo "")
        LAST_TAG="${{ steps.get_tag.outputs.last_tag }}"
        
        TAG_CREATED="false"
        
        if git rev-parse "$NEW_VERSION" >/dev/null 2>&1; then
          if [ "${LAST_TAG}" != "${NEW_VERSION}" ]; then
            if [ "${{ inputs.debug }}" = "true" ]; then
              echo "ğŸ” [DEBUG] Tag $NEW_VERSION already exists at the current commit $CURRENT_COMMIT"
            fi
          else
            if [ "${{ inputs.debug }}" = "true" ]; then
              echo "ğŸ” [DEBUG] Tag $NEW_VERSION exists but points to $NEW_VERSION, updating to $CURRENT_COMMIT"
            fi
            git tag -d "$NEW_VERSION"
            git tag "$NEW_VERSION"
            git push origin ":refs/tags/$NEW_VERSION"
            git push origin "$NEW_VERSION"
          fi
        else
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "ğŸ” [DEBUG] Creating tag $NEW_VERSION at commit $CURRENT_COMMIT"
          fi
          git tag "$NEW_VERSION"
          git push origin "$NEW_VERSION"
          TAG_CREATED="true"
        fi
        
        echo "Tags created: $TAG_CREATED"
        echo "tag_created=$TAG_CREATED" >> $GITHUB_OUTPUT

    # ========== 8. RÃ©sumÃ© final ==========
    - name: 'Summary'
      id: summary
      shell: bash
      run: |
        echo "=========================================="
        echo "âœ… Semantic Versioning Complete"
        echo "=========================================="
        echo "ğŸ“Œ Version: ${{ steps.bump.outputs.new_version }}"
        echo "ğŸ“Š Bump Type: ${{ steps.bump.outputs.bump_type }}"
        echo "ğŸ“ Changelog: ${{ steps.changelog.outputs.has_changes }}"
        echo "ğŸ·ï¸ Tag Created: ${{ steps.tag.outputs.tag_created }}"
        echo "=========================================="